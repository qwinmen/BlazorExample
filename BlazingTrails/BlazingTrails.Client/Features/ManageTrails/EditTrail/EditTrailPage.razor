@page "/edit-trail/{TrailId:int}"
@using BlazingTrails.Shared.Features.ManageTrails.Shared
@using BlazingTrails.Shared.Features.ManageTrails.EditTrail
@inject IMediator Mediator

<PageTitle>Редактирование тропы</PageTitle>

<nav aria-label="breadcrumb">
	<ol class="breadcrumb">
		<li class="breadcrumb-item">
			<a href="/">Home</a>
		</li>
		<li class="breadcrumb-item active" aria-current="page">Редактировать</li>
	</ol>
</nav>

@if (_isLoading)
{
	<p>Загрузка тропы ...</p>
}
else
{
	<h3 class="mt-5 mb-4">Изменение данных: @_trail.Name</h3>
	@if (_submitSuccessful)
	{
		<SuccessAlert Message="Изменение выполнено успешно!"/>
	}
	else if (_errorMessage is not null)
	{
		<ErrorAlert Message="@_errorMessage"/>
	}

	<TrailForm Trail="_trail" OnSubmit="SubmitEditTrail"/>
}

@code {
	private bool _isLoading;
	private bool _submitSuccessful;
	private string? _errorMessage;
	private readonly TrailDto _trail = new TrailDto();

	[Parameter]
	public int TrailId { get; set; }

	protected override async Task OnInitializedAsync()
	{
		_isLoading = true;
		GetTrailRequest.Response response = await Mediator.Send(new GetTrailRequest(TrailId));

		if (response.Trail is not null)
		{
			_trail.Id = TrailId;
			_trail.Name = response.Trail.Name;
			_trail.Description = response.Trail.Description;
			_trail.Location = response.Trail.Location;
			_trail.Image = response.Trail.Image;
			_trail.Length = response.Trail.Length;
			_trail.TimeInMinutes = response.Trail.TimeInMinutes;
			_trail.Route.Clear();
			_trail.Route.AddRange(response.Trail.RouteInstructions.Select(ri => new TrailDto.RouteInstruction
				{
					Stage = ri.Stage,
					Description = ri.Description,
				}));
		}
		else
		{
			_errorMessage = "Ошибка при загрузке выбранной тропы!";
		}

		_isLoading = false;
	}

	private async Task SubmitEditTrail(TrailDto trail, IBrowserFile? image)
	{
		EditTrailRequest.Response response = await Mediator.Send(new EditTrailRequest(trail));
		if (!response.IsSuccess)
		{
			_submitSuccessful = false;
			_errorMessage = "Ошибка при сохранении тропы!";
		}
		else
		{
			_trail.Name = trail.Name;
			_trail.Description = trail.Description;
			_trail.Location = trail.Location;
			_trail.Length = trail.Length;
			_trail.TimeInMinutes = trail.TimeInMinutes;
			_trail.Route.Clear();
			_trail.Route.AddRange(trail.Route.Select(ri => new TrailDto.RouteInstruction
				{
					Stage = ri.Stage,
					Description = ri.Description,
				}));

			_submitSuccessful = true;
			if (trail.ImageAction == ImageAction.Add)
			{
				_submitSuccessful = await ProcessImage(trail.Id, image!);
			}

			if (trail.ImageAction == ImageAction.Remove)
			{
				_trail.Image = string.Empty;
			}
		}

		StateHasChanged();
	}

	private async Task<bool> ProcessImage(int trailId, IBrowserFile trailImage)
	{
		UploadTrailImageRequest.Response imageUploadResponse = await Mediator.Send(new UploadTrailImageRequest(trailId, trailImage));
		if (string.IsNullOrWhiteSpace(imageUploadResponse.ImageName))
		{
			_errorMessage = "Ошибка: вся информация о тропе сохранена, кроме изображения!";
			return false;
		}

		_trail.Image = imageUploadResponse.ImageName;
		return true;
	}

}
